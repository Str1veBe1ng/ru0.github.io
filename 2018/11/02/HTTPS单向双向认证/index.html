<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>HTTPS单向双向认证 | ru0</title><meta name="description" content="HTTPS单向双向认证 - ruo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="ru0"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="ru0"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="/mind" target="_self">HACKMIND</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/ru0" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">HTTPS单向双向认证</h1><div class="post-info"><a></a>2018-11-02</div><div class="post-content"><ul>
<li>JKS：数字证书库。JKS里有KeyEntry和CertEntry，在库里的每个Entry都是靠别名（alias）来识别的。</li>
<li>P12：是PKCS12的缩写。同样是一个存储私钥的证书库，由.jks文件导出的，用户在PC平台安装，用于标示用户的身份。</li>
<li>CER：俗称数字证书，目的就是用于存储公钥证书，任何人都可以获取这个文件 。</li>
<li>BKS：Android平台专用证书库格式。</li>
</ul>
<p>crt转bks</p>
<p>下载Bouncy Castle，将该文件放到Java\jdk1.8.0_20\jre\lib\ext目录下，或者使用-providerpath指定路径。<br><a href="http://www.bouncycastle.org/latest_releases.html" target="_blank" rel="external">http://www.bouncycastle.org/latest_releases.html</a></p>
<p>keytool -importcert -v -trustcacerts -alias mykey -file githubcom.crt -keystore keystore.bks -storetype BKS -providerclass org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath bcprov-jdk15on-1.47.jar -storepass testing</p>
<h1 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h1><h3 id="SSL-Pinning"><a href="#SSL-Pinning" class="headerlink" title="SSL Pinning"></a>SSL Pinning</h3><p>在客户端预置服务器公钥证书或者指纹，在和HTTPS请求获取的服务器证书做对比的方式。</p>
<h1 id="双向验证"><a href="#双向验证" class="headerlink" title="双向验证"></a>双向验证</h1><p>什么是双向认证？举个栗子。</p>
<blockquote>
<p>土匪：蘑菇，你哪路？什么价？（什么人？到哪里去？）<br>杨子荣：哈！想啥来啥，想吃奶来了妈妈，想娘家的人，孩子他舅舅来了。（找同行）<br>杨子荣：拜见三爷！<br>土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？）<br>杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。）</p>
</blockquote>
<p>简单来说，当两个互不认识的人交易的时候，在A说出口令之后，B能说出只有A和B知道的口令。</p>
<h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><p>1） 生成客户端keystore</p>
<p><code>keytool -genkeypair -alias client -keyalg RSA -validity 3650 -keypass 123456 -storepass 123456 -keystore client.jks</code></p>
<p>2） 生成服务端keystore</p>
<p><code>keytool -genkeypair -alias server -keyalg RSA -validity 3650 -keypass 123456 -storepass 123456 -keystore server.keystore</code></p>
<p>注意：CN必须与IP地址匹配，否则需要修改host</p>
<p>3） 导出客户端证书</p>
<p><code>keytool -export -alias client -file client.cer -keystore client.jks -storepass 123456</code></p>
<p>4） 导出服务端证书</p>
<p><code>keytool -export -alias server -file server.cer -keystore server.keystore -storepass 123456</code></p>
<p>5） 证书交换</p>
<p>将客户端证书导入服务端keystore中，再将服务端证书导入客户端keystore中，一个keystore可以导入多个证书，生成证书列表。</p>
<p>生成客户端信任证书库(由服务端证书生成的证书库)：<br><code>keytool -import -v -alias server -file server.cer -keystore truststore.jks -storepass 123456</code></p>
<p>将客户端证书导入到服务器证书库(使得服务器信任客户端证书)：<br><code>keytool -import -v -alias client -file client.cer -keystore server.keystore -storepass 123456</code></p>
<p>6） 生成Android识别的BKS库文件</p>
<p>使用portecle将client.jks和truststore.jks转换成bks格式，放到android客户端的assert目录下。</p>
<h3 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h3><p>修改server.xml文件，配置8443端口 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</div><div class="line">           maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</div><div class="line">           clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot;</div><div class="line">           keystoreFile=&quot;$&#123;catalina.base&#125;\conf\server.keystore&quot; keystorePass=&quot;123456&quot; </div><div class="line">           truststoreFile=&quot;$&#123;catalina.base&#125;\conf\server.keystore&quot; truststorePass=&quot;123456&quot; /&gt;</div></pre></td></tr></table></figure>
<p>由于没有客户端证书，浏览器访问将被拒绝。</p>
<p><img src="https://i.imgur.com/X0cRtx6.png" alt=""></p>
<h3 id="安卓客户端"><a href="#安卓客户端" class="headerlink" title="安卓客户端"></a>安卓客户端</h3><!-- code -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">    // 服务器端需要验证的客户端证书，其实就是客户端的keystore</div><div class="line">    KeyStore keyStore = KeyStore.getInstance(&quot;BKS&quot;);</div><div class="line">    // 客户端信任的服务器端证书</div><div class="line">    KeyStore trustStore = KeyStore.getInstance(&quot;BKS&quot;);</div><div class="line"></div><div class="line">    //读取证书</div><div class="line">    InputStream ksIn = getResources().getAssets().open(&quot;client.bks&quot;);</div><div class="line">    InputStream tsIn = getResources().getAssets().open(&quot;truststore.bks&quot;);</div><div class="line"></div><div class="line">    //加载证书</div><div class="line">    keyStore.load(ksIn,&quot;123456&quot;.toCharArray());</div><div class="line">    trustStore.load(tsIn,&quot;123456&quot;.toCharArray());</div><div class="line">    IOUtils.close(ksIn);</div><div class="line">    IOUtils.close(tsIn);</div><div class="line"></div><div class="line">    //初始化SSLContext</div><div class="line">    SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);</div><div class="line">    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(&quot;X509&quot;);</div><div class="line">    KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(&quot;X509&quot;);</div><div class="line">    trustManagerFactory.init(trustStore);</div><div class="line">    keyManagerFactory.init(keyStore, &quot;123456&quot;.toCharArray());</div><div class="line">    sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);</div><div class="line"></div><div class="line">    //通过HttpsURLConnection设置链接</div><div class="line">    SSLSocketFactory socketFactory = sslContext.getSocketFactory();</div><div class="line">    HttpsURLConnection.setDefaultSSLSocketFactory(socketFactory);</div><div class="line"></div><div class="line">    URL url = new URL(url);</div><div class="line">    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</div><div class="line">    //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置</div><div class="line">    conn.setHostnameVerifier(new HostnameVerifier() &#123;</div><div class="line">        @Override</div><div class="line">        public boolean verify(String hostname, SSLSession session) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    InputStream inputStream = conn.getInputStream();</div><div class="line">    String content = getString(inputStream);</div><div class="line">    IOUtils.close(inputStream);</div><div class="line">    System.out.println(content);</div><div class="line"></div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Burp-代理"><a href="#Burp-代理" class="headerlink" title="Burp 代理"></a>Burp 代理</h2><p>提取app中的客户端证书，在Burp的Project options -&gt; SSL选项卡Client SSL Certificates栏处导入，之后Burp便可直接访问目标站点。</p>
<p><img src="https://i.imgur.com/CHvcAzX.png" alt=""></p>
<p>app客户端依旧使用Xposed JustTrustMe插件绕过服务器证书校验。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2019/03/19/ELK/">prev</a><a class="next" href="/2018/05/11/Password-Crack-Tips/">next</a></div><div class="copyright"><p>&copy; 2020 <a href="http://ruos.org">ruo</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>